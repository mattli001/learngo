

# [原始英文位置](https://dgraph.io/blog/post/manual-memory-management-golang-jemalloc/)
# 使用jemalloc在Go中進行手動內存管理

自2015年成立以來，Dgraph Labs一直是Go語言的用戶。五年之後，Go代碼達到20萬行，我們很高興地報告，我們仍然堅信Go是並且仍然是正確的選擇。我們對Go的興奮不僅限於構建系統，還使我們甚至可以使用Go編寫腳本，這些腳本通常是用Bash或Python編寫的。我們發現使用Go可以幫助我們構建乾淨，可讀，可維護並且最重要的是高效並發的代碼庫。

但是，自早期以來，我們一直關注的一個領域是： 內存管理。我們沒有反對Go垃圾收集器的方法，但是儘管它為開發人員提供了便利，但它具有其他內存垃圾收集器所面臨的相同問題：*`它根本無法與手動內存管理的效率競爭`*。


當您手動管理內存時，內存使用率較低，可預測，並且允許突發的內存分配不會引起內存使用率的瘋狂飆升。對於使用Go內存的Dgraph，所有這些都是問題1。實際上，Dgraph遇到內存不足，是我們從用戶那裡聽到的非常普遍的抱怨。

諸如Rust之類的語言之所以得到發展，部分原因是它允許安全的手動內存管理。我們可以完全理解。

根據我們的經驗，與嘗試使用具有垃圾回收的語言優化內存使用2相比，進行手動內存分配和解決潛在的內存洩漏花費的精力更少。在構建具有幾乎無限的可伸縮性的數據庫系統時，手動內存管理非常值得解決。

我們對Go的熱愛和避免使用Go GC的需求，使我們找到了在Go中進行手動內存管理的新穎方法。當然，*`大多數Go用戶將永遠不需要手動進行內存管理。除非您需要，否則我們建議您不要這樣做。`* 當您確實需要它時，您就會知道。

在這篇文章中，我將分享我們在Dgraph Labs中從對手動內存管理的探索中學到的知識，並說明我們如何在Go中手動管理內存。

## 通過Cgo創建內存

靈感來自 Cgo Wiki 的 [將C數組轉換為Go切片](https://github.com/golang/go/wiki/cgo#turning-c-arrays-into-go-slices)的文章。我們可以使用 mallocC 分配內存，然後將 unsafe 其傳遞給 Go，而不會受到 Go GC 的干擾。
